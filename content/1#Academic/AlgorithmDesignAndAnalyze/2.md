---
layout: collection


title: '递归与分治'
collection: AlgorithmDesignAndAnalyze
---


## 分治法概念

>不是所有递归函数都可以找到非递归的定义

分治法适用条件：

- 问题规模缩小到一定程度可以很容易解决
- 问题可以分解为若干个规模较小的相同问题，即**最优子结构**性质
- 子问题的（简单）合并可以得到原问题的解
	- 如果不满足，考虑贪心或动态规划
- 大问题分解为子问题后各个子问题可以独立（并行、同时）求解，相互无依赖关系，不包含公共子问题
	- 如果存在公共子问题，使用动态规划

>平衡子问题：如果可以，把问题一分为二总是比其他划分方法更好。

>正例：二分搜索、合并排序

>反例：汉诺塔问题

## 算法复杂性分析

如果把规模为`n`的问题分解成`k`个规模为`n/m`的子问题，合并结果的时间为`f(n)`，最小子问题为`n0`，则时间复杂度为

```
T(n)=O(1)            n=n0
T(n)=kT(n/m)+f(n)    n>n0
```

通过迭代法求得方程的解

```
T(n)=n^(logm(k))+Σ(j=0 -> logm(n-1))k^jf(n/m^j)
```

### m & k的影响

- 如果`m < k`，也就是说`k * (n / m) > n`，分解后问题规模大于原问题规模
	- T(n)复杂性较大，如矩阵乘法问题
- 如果`m = k`，分解后问题规模等于原问题规模
	- 合并排序
- 如果`m > k`，分解后问题规模小于原问题规模（减治）
	- 二分查找

## 二分查找

已知**有序**数组`a[n]`，从`a[l]`到`a[r]`中找元素`aim`

流程（以升序数组为例）：

- 比较l和r
	- 如果`l==r`且`a[l]==aim`那么`aim`的下标就是l。如果`a[l]!=aim`那么数组中没有`aim`
	- 如果`l!=r`那么令`mid=(l+r)/2`，比较`a[mid]`和`aim`
		- 如果`a[mid]>aim`，令`r=mid-1`
		- 如果`a[mid]<aim`，令`l=mid+1`

复杂度O(logn)

## 大整数乘法

使用加法换乘法的思想

两个`n`位二进制大整数分别为`x`和`y`，把`x`和`y`分别均分成两部分，即`x`的左边`n/2`位为`a`，右边`n/2`为`b`，记为`x=ab`。同理令`y=cd`。则`x*y`可以计算为

```
x = a * 2^(n/2) + b
y = c * 2^(n/2) + d
x * y = a*c*2^n + (b*c+a*d)*2^(n/2) + b*d
```

上式包含四次`n/2`规模的乘法，计算发现`T(n)=4T(n/2)+O(n)`，`T(n)=O(n^2)`，没有改进

如果要改进，必须减少乘法次数。改进方案如下

```
x * y = a*c*2^n + ((a-b)(d-c) + a*c + b*d)*2^(n/2) + b*d
```

式中`a*c`和`b*d`均出现了两次，只需要计算一次保存结果就行了。所以一共出现了三次规模`n/2`的乘法，所以`T(n)=3T(n/2)+O(n)`，复杂度`T(n)=O(n^1.59)`

## 合并排序

最小子问题规模为2，只要简单比大小就可以把两个元素排序

思想是每次把问题拆分成两个（相等的）子问题，把两个子序列排序之后合并

复杂度`T(n)=2T(n/2)+O(n)`具体计算得到`T(n)=O(nlogn)`

需要辅助空间O(n)

特点

- 分解简单
- 合并复杂

## 快速排序

以升序为例

按照基准元素把序列划分为三个子序列`a[l:q-1], a[q], a[q+1, r]`，其中`a[l:q-1]`中所有元素小于`a[q]`，`a[q+1:r]`中所有元素大于`a[q]`。

策略：指针i从左向右搜索，指针j从右向左搜索，当`a[i]>a[q]&&a[j]<a[q]`的时候交换`a[i]`与`a[j]`。

个人感觉这个策略没有学习数据结构时的那个交替的策略好

改进策略

- 判断子序列是否已经有序
- 随机选择基准元素

时间复杂性

- 最坏 O(n^2)
- 平均 O(nlogn)

辅助空间O(n)或O(logn)

## 线性时间选择

从快速排序的思想延伸而来。用于寻找序列中第`k`大的元素而不需要把整个序列完全排序。

思路：和快排类似，选择基准元素并把序列分为3份。目标元素在其中一份中，以此做到减治

基准元素的选择：把序列元素以5个一组分组，用任意排序方法（如冒泡）把所有组的5个元素排序，取出所有组的中位数，并求这些中位数的中位数。

优化：当序列长度小于指定值（理论上应取20）时直接简单排序求第k个元素

复杂度`T(n)=O(n)`

## 平面最近点对（略）

### 面向一维的算法

寻找坐标中位数m作为分割点把所有点分成两部分

## 矩阵乘法（略）

## 棋盘覆盖（略）

