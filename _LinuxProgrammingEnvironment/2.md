---
layout: collection
author: DiscreteTom
catalog: true
title: '文本文件处理'
collection: LinuxProgrammingEnvironment
---

## 预备知识

文本文件相比二进制文件浪费空间

系统配置信息存放在`/etc`目录下，功能上类似windows注册表

因特网大部分传输层(TCP)以上的网络协议都是文本型协议

## 重定向与管道

- 输出重定向 - `>`（输出到文件，即**使用文件替代标准输出**
- 输入重定向 - `<`（从文件输入，即**使用文件替代标准输入**
- 管道 - `|`（把前一个操作的标准输出作为后一个操作的标准输入

## 文本文件处理命令特点

通常程序从标准输入获取数据，标准输出显示数据。只有使用重定向或管道才会修改输入输出流

linux自带文本文件处理指令不指定处理对象文件名时从**标准输入获得数据，输出到标准输出**，且多数命令支持指定多个文件

shell文件通配符`*`对文件进行匹配是系统的工作，对程序不可见

## 逐屏显示文件

可以使用的指令：
- `pg` - 已过时，废弃
- `more`
  - 使用方法：`more filename`
  - 系统自带的文本处理指令，不提供filename时使用标准输入作为文件内容，所以可以结合管道使用
  - 按下空格向下滚动一屏
  - 按下回车向下滚动一行
  - `q`退出
  - `/pattern`模式匹配pattern（支持正则表达式
  - `/`查找下一个匹配的字符串
  - `h`显示帮助
  - `ctrl+L`屏幕刷新
  - 可以指定多个文件，多个文件依次显示
  - 缺点 - 不能向上滚
- `less`（有些linux系统不支持
  - 相比于`more`指令，less可以向上滚
  - 可以使用方向键、vim光标移动键、PageUp/PageDown/Home/End键定位，功能更强
  - 'less is more' - 据说文档是这么写的

## 显示文件内容

- cat(concatenate)
  - 把文件视为文本打印
  - 参数`-n`显示行号
  - 支持输入多个文件
  - 无参数时从标准输入输入，使用ctrl+d（EOF）结束，所以可以直接使用`cat > filename`进行文件输入
  - 可以使用`cat file_1 file_2 > file`进行文件拼接
- od(octal dump)
  - 按字节显示
  - 参数`-c`逐字符打印文件，遇到不可打印字符时打印编码（八进制
  - 参数`-t x1`以十六进制打印
- head & tail
  - 显示文件的头部和尾部
  - 参数`-n`选择行数
    - 输入多个文件时，每个文件都输出选择的行数
    - 如果输入行数为负，则把文件剩余部分均作为头/尾（类似于python中的切片
  - `tail -f filename`实时打印文件尾被追加的内容（有些系统不支持此选项
- tee
  - 三通，把输入内容回显到stdout并写入文件
  - 可以重定向到设备文件以实现两个屏幕同时显示
- wc(word count)
  - 列出文件的行数、单词数、字符数
  - 输入文件超过1个时显示合计数据
  - 参数`-l`仅显示行
- sort
  - 排序文件内容，默认按照ascii码排序（67>123
  - 参数`-n`按照数字排序（123>67
  - 有繁多的排序参数，此处略
- tr
  - 把标准输入的部分内容**逐字符（不是以字符串为单位）**替换后输出到标准输出（常和管道一起用
    - 例1 - `cat ls | tr abc 123`是把a换成1，b换成2，c换成3
    - 例2 - `cat ls | tr abb 123`是把a换成1，b换成2，b换成3（覆盖前面的‘b换成2’
  - 可以使用`'[]'`指定一个集合，如`tr '[a-z]' '[A-Z]'`
  - 可以使用`\`配合三个八进制数字表示一个字符，如`tr % '\012'`，注意使用**单引号**
- uniq
  - 筛选文件中的重复行（两行必须相邻
  - 经常和sort一起使用，先排序再删除相邻行，就不会出现相同的行了
  - `-u`只输出没有重复的行（unique
  - `-d`只输出重复的行，但是每行只输出一次（duplicated
  - 没有`-u`&`-d`时，输出没有重复的行和重复的行（重复的行只输出一次
  - `-c`输出各行出现了几次

## 正则表达式

不同软件的正则表达式规则可能不同

regular expression

简写：
- regex
- regexp
- RE

### 原始正则表达式

六个元字符
- `.`
- `*`
- `[`
- `\`
- `^`
- `$`

匹配规则：
- 单字符
  - 非元字符与自身匹配
  - 元字符前面加上转义字符`\`可以与自身匹配。`\`后面只能紧接着元字符，否则视为undefined
  - 元字符`.`可以匹配任意单字符
- 连接
  - 顺序写就是连接，如`abc`匹配`abc`
- 集合
  - `[]`中的内容视为一个集合，匹配集合中的一个字符
  - 如`[abc]`表示可以匹配a或b或c
  - `[]`中的`\.*`表示其自身而不是元字符
  - 取最外层匹配的方括号，所以`[][]`匹配`[`&`]`
  - 可以使用减号`-`定义区间，如`[a-d]`、`[a-zA-Z0-9]`。减号前后无字符时失去区间的意义，和普通字符一样，如`[ab-]`匹配a或b或-
  - `^`在集合首时，表示求补集，如`[^a-z]`表示匹配任意非小写字母。不在集合首时失去意义，如`[a-z^]`匹配27个字符
- 星号`*`
  - 单字符后面接`*`表示此字符出现任意次（0到正无穷
  - 因为集合`[]`仅匹配一个字符，所以也可以使用`*`，如`[0-9]*`
- 锚点
  - `$`在尾部时表示行尾，如`123$`匹配行尾的123
  - `^`在行首时表示行首，如`^123`匹配行首的123

### 扩展正则表达式

- 因为原始正则表达式复杂而产生的扩展正则表达式ERE
- 早期Linux系统使用Perl脚本语言作为文本处理，所以也出现了PCRE: Perl-compatible RE

常见扩展规则：
- 分组
  - 使用圆括号`()`表示分组，如`(xy)*`可以匹配xy/xyxy/xyxyxy/...
- 逻辑或
  - 使用`|`表示逻辑或。常用于分组中，如`(green|red)`表示匹配green或red
- 重复次数
  - `+`表示1次或多于1次
  - `?`表示0或1次
  - 限定重复次数`\{m,n\}`表示m到n次。转义字符`\`使大括号变成了元字符
- 预定义集合
  - 通过扩展转义字符实现
  - `\d`表示数字，`\D`表示非数字
  - ...

### 例：vim中的RE

如，使用替换指令：`:1,$s/[0-9]+/xx/g`

其中：
- `:`表示vim指令
- `1`表示指令起始位置为第一行
- `$`表示指令结束位置为最后一行
- `s`表示指令为替换
- `/`用来分隔替换的字符串
- `[0-9]+`表示匹配目标为所有长度大于0的数字
- `xx`表示替换目标串
- `g`表示如果一行中有多个这样的匹配则全部替换

## 文本行筛选

grep(Global RE Print) - 全局正则表达式输出

语法 - `grep pattern filename(s)`，其中正则表达式使用单引号引起

参数：
- -F/--fixed-strings - 直接匹配字符串而不是RE（相当于fgrep
- -G/--basic-regexp - 匹配基础RE
- -E/--extended-regexp - 匹配ERE
- -P/--perl-regexp - 匹配PCRE
- -n - 显示行号
- -i - 忽略大小写
- -v - 显示所有不包含模式的行（即反选

相关指令
- egrep - 使用ERE的grep
- fgrep - 直接使用字符串快速搜索而不是使用RE

## 流编辑

行编辑器ed（废弃

流编辑器sed

用法：
- `sed 'command' filenames` - 没有文件输入时默认使用标准输入
- `sed -e 'command1' -e 'command2' filenames` - 每个`-e`后面可以接一个新的指令。可以使用很多`-e`
- `sed -f cmd_filename filenames` - 使用文件`cmd_filename`中的命令

常用命令：
- 类似于VIM中的替换表达式`s/raw_str/aim_str/g`，支持正则表达式
- 可以使用`\(`&`\)`来给提取表达式中的内容。`\0`匹配原正则表达式，`\n`表示第n个`\(`&`\)`中的内容，n只能为0-9
  - 如把日期格式`月-日-年`改为`年.月.日`，比如`04-26-1997 -> 1997.04.26`，可以使用`s/\([0-9][0-9]\)-\([0-9][0-9]\)-\([0-9][0-9]*\)/\3.\1.\2/g`。其中`\3`表示提取出的年，`\1`表示提取出的月，`\2`表示提取出的日。

## 复杂编辑

`awk`指令 - 使用逐行处理文本的**特殊语言**处理文本（awk是此程序三位设计者的名字的首字母

usage:
- `awk 'program' filenames`
- `awk -f program_filename filenames`

程序格式：`条件 {动作}`。awk自动对每行文本执行条件判断，满足条件则执行动作（内置循环

允许使用多段程序，程序之间使用空格或分号隔开

数据单元：
- 每行视为一个**记录**，内置变量`NR`为行号
- 每行中被分隔符分开的部分称为**域**。分隔符可手动更改，默认为空白符（类似于python里面不加参数的`str.split()`）内置变量`$n`表示第n个域，`$0`表示整行

awk使用类似于C语言的语法，支持以下操作：
- 算术运算
- 关系运算
- 逻辑运算
- 正则表达式模式匹配
  - 匹配运算符为`~`，不匹配为`!~`
  - 比如：`$2 ~ "[1-9][0-9]*"`
- 关键字`BEGIN`表示开始处理所有文本之前执行的操作
- 关键字`END`表示处理所有文本之后执行的操作
- 自定义变量的赋值（脚本语言，不需要声明甚至不需要初始化，数字默认0
- 流程控制语句`if` & `for` & 表示程序块的`{}`
- 输出`print arg1, arg2, ...`（不需要括号，类似于python
- 格式输出`printf("format_string", arg1, arg2, ...)`

程序举例：
- `awk '/guest/{printf("%s ", $2)}'` - 对于内容存在`guest`的行，输出其第二个域，输出使用空格分隔
- `awk '$1 > 2000 {print $2}'` - 对于第一个域大于2000的行，输出此行第二个域

## 文件比较

### cmp

`usage: cmp file1 file2`

判断两个文件是否相同，文件不相同时输出第一个不同之处。文件完全相同时不输出。

WINDOWS系统中类似的指令为`COMP`

### 使用哈希算法的文件比较

常用于验证两个机器上的文件完整性

- `md5sum` - 使用MD5算法可以生成16字节哈希值（即2^128分之一的撞车率）
- `sha1sum` - 使用SHA-1算法生成20字节哈希值
- `sha512sum` - 类似

用法（以`md5sum`为例：
- `md5sum filenames` - 生成哈希值。通常重定向输出到一个logfile里用来验证完整性
- `md5sum -c logfile` - 使用logfile的内容检查文件夹内的文件。无误时输出OK

```
# ls
a.out  test.cpp
# md5sum a.out
84dbb852f8ec476ebb91c77dd4e52bb5  a.out
# md5sum a.out test.cpp
84dbb852f8ec476ebb91c77dd4e52bb5  a.out
b59e3b634fb2cbb321172de0548b5076  test.cpp
# md5sum a.out test.cpp > log.txt
# md5sum -c log.txt
a.out: OK
test.cpp: OK
```

### diff

使用最长公共子序列算法，列出两个文件的区别。可以用于版本管理

usage:
- `diff file1 file2`
- `diff -u file1 file2`

比较两个**文本文件**，寻找二者差别

输出格式：
- normal
- unified

-u参数会显示改变处前后3行的信息。-un会显示前后n行的信息，如-u0不显示前后行的信息

## vi

功能强大体积小。不支持编程语言的语法高亮和代码补全，仅为文本编辑器

两个模式：编辑模式和命令模式

### 用户偏好设置

用户偏好设置保存在用户目录下的`.exrc`文件中（如果没有可以自行创建

每个用户单独一份。用户自行设置内容

常用内容：
- `set number` - 启动行标
- `set tabstop=4` - 设置制表符长度为4

也可以在运行时设置，命令为`:set xxx`

### vi指令与命令（略

- `^` - 行首
- `$` - 行尾
- `ctrl+b` - 向后翻页
- `ctrl+f` - 向前翻页
- `:123` - 光标跳转到第123行
- `:$` - 光标跳转到文件尾
- `.` - 表示当前行号。直接按下`.`表示重复上一次编辑操作
- `$` - 表示最后一行行号
- `%` - 括号配对
- `J` - 行合并
- `ctrl+l` - 刷新屏幕显示
- `ctrl+g` - 显示状态
- `/pattern` - 使用**正则表达式**模式查找
- `n` - 查找下一个
- `N` - 查找上一个
- `:n1,n2s/pattern/string/g` - 模式替换
  - `n1` & `n2`是行号。可以是数字，也可以使用`.`表示当前行，`$`表示末行
  - `s`表示substitution，即替换
  - pattern使用正则表达式。可以用`^`表示行首`$`表示行尾
  - `g`表示如果行内出现多次则行内替换所有匹配项
  - **小心陷阱**：因为使用正则表达式，所以`/a[i]/b[i]/`并不能把`a[i]`替换为`b[i]`
  - 出现正则表达式元字符时切记使用`\`转义
  - 可以把`s`后面的`/`改为其他字符，如`:`/`^`/`$`等，命令格式就会变成`:n1,n2s^pattern^string^g`，相当于替换了命令中的分隔符。
  - 类似于sed指令，可以使用`\(` & `\)`来保存结果，在目标string中可以使用`\1`/`\2`/...来引用

## 编辑时常遇到的异常情况

### 编辑器“假死”

鉴于windows系统中使用ctrl组合键实现保存，所以在linux中常常会误按`ctrl+s` & `ctrl+z`

`ctrl+s`使系统进入流量控制状态。使用`ctrl+q`解除流量控制

`ctrl+z`使进程被挂起suspend，暂停运行，进程处于stopped状态。在bash使用jobs或bg命令可以查看后台进程。使用`fg n`或`fg %n`或直接在bash输入`%n`恢复n号作业

### backspace无法使用

现象：输入bash命令时backspace可用，运行自己写的程序时backspace无法使用

原因：行律设置不正确。

backspace的ascii码是`ctrl+h`，执行`stty erase ^H`即可设定。使用`ctrl+h`和backspace都可以删除

### 屏幕乱码

通常是把二进制文件作为文本输出导致。输出的过程中可能恰巧输出了转义字符导致终端字符集被修改。断开连接重新登录即可

### 文本文件格式问题

linux文件在windows下打开，所有内容在一行内

因为windows识别的是回车换行，linux仅识别换行。在linux端进行格式转换即可

### 中文编码问题

现象：从windows迁移来的文件只有中文字符乱码

原因：文件使用GBK编码而非UTF-8

检查linux系统与终端设置：linux与语言相关的环境变量`LANG`应为`en_US.UTF-8`。设置方法：`export LANG=en_US.UTF-8`。终端字符集自行设置（如在putty里面设置。注意要使用中文字体，否则字库里面没有对应编码的字形

或者使用命令`iconv -f gbk -t utf8`