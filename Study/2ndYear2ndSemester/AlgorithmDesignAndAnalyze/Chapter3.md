# 算法设计与分析 目录

- [第一章 概述](Chapter1.md)
- [第二章 递归分治](Chapter2.md)
- [第三章 动态规划](Chapter3.md)
- [第四章 贪心算法](Chapter4.md)
- [第五章 回溯法](Chapter5.md)
- [第六章 分支限界法](Chapter6.md)
- [总结](Summary.md)

# 第三章 动态规划

## 动态规划思想

基本要素

- 最优子结构
- 重叠子问题!!!!

使用自底向上构建的方式避免计算重叠子问题

## 矩阵连乘

利用动态规划寻找最小乘法次数

举例：现有A、B、C、D四个矩阵，他们的维度分别是

- A=50*10
- B=10*40
- C=40*30
- D=30*5

为了计算ABCD，我们可以给矩阵加括号，一共有5种加括号的方式，这些加括号方式和计算代价分别为

- (A((BC)D)) - 16000
- (A(B(CD))) - 10500
- ((AB)(CD)) - 36000
- (((AB)C)D) - 87500
- ((A(BC))D) - 34500

所以我们的目标是根据矩阵维度求得使计算代价最小的加括号方式

显然此问题拥有最优子结构性质

自下而上构建，最小子问题是两个（相邻）矩阵相乘。子问题的划分方式是在相邻的N个矩阵中添加一个分隔符，拆分成两组矩阵。一共有N-1中分隔方式，选择最小者作为规模为N个矩阵的值

算法内含三重循环，时间上界为O(n^3)，空间占用O(n^2)

## 最长公共子序列

已知两个序列X(m)和Y(n)

思想：令a(i,j)为**X(0:i)和Y(0:n)的最长子序列长度**，那么如果```X(i+1)==Y(j+1)```，则```a(i+1,j+1)=a(i,j)+1```。如果```X(i+1)!=Y(j+1)```，那么```a(i+1,j+1)=max{a(i,j+1), a(i+1,j)}```

时间复杂度O(m+n)

## 最大子段和

已知数列```a(m)```。

思想：令```b(j)```为以a(j)为最右侧元素的最大子段和。递归方程```b(j)=max{b(j-1)+a(j), a(j)}```，也就是说如果以a(j-1)结尾子段的最大子段是负数，那么a(j)自身就是以a(j)结尾的字段的最大子段和

时间、空间复杂度O(n)

## 凸多边形最优三角剖分

已知顶点集合```{v0, v1, ..., vn}```，```w(i, j, k)```为以vi、vj、vk为顶点的三角形的权值。令```a(i, j)```为从vi到vj构成的多边形的最优三角剖分值。那么对于大问题a(0, n)，应该从v1到v(n-1)中选择一个点p使```a(0, p)+a(p, n)+w(0, p, n)```的值最小。

自下而上，用三角形的权值生成多边形的权值

内含三重循环，时间复杂度O(n^3)，空间复杂度O(n^2)

## 0-1背包问题

已知n+1个物品，重量w0-wn，价值v0-vn，已知背包容量M

令```a(i,j)```为背包容量为j，可选择物品范围为0-i的背包内物品价值最大值

递归关系：```a(i,j)=max{a(i-1,j), a(i, j-wi)+vi}```，也就是说从“放入第i个物品”和“不放入第i个物品”中选择最优解

时间复杂度O(nM)

觉得有用？欢迎[打赏](../../../donate.md)

:)

[返回主页](../../../index.md)