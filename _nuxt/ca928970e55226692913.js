(window.webpackJsonp=window.webpackJsonp||[]).push([[30,248,249,250,251,252,253,254,255,256,257,258],{1063:function(v,_,n){const l={render:function(){this.$createElement;return this._self._c,this._m(0)},staticRenderFns:[function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("div",{staticClass:"frontmatter-markdown"},[l("h2",[v._v("定点数的表示方法")]),v._v(" "),l("p",[v._v("没有小数点，只能表示纯小数或纯整数")]),v._v(" "),l("h3",[v._v("无符号数 & 有符号数")]),v._v(" "),l("p",[l("strong",[v._v("无符号数都是非负的")]),v._v("。如一个16位2进制数的表示范围为0~65535")]),v._v(" "),l("p",[v._v("有符号数的最左侧位（第一位）为符号位，符号位为0表示正数，符号位为1表示负数")]),v._v(" "),l("p",[v._v("如：8位2进制有符号数00001001表示+0001001，10001001表示-0001001")]),v._v(" "),l("p",[v._v("对小数来说，"),l("strong",[v._v("个位就是符号位")]),v._v("，如1.0000010表示-0.0000010，0.0101001表示+0.0101001")]),v._v(" "),l("p",[v._v("有符号数花费一位作为符号，取值范围的大小基本不变（也可能取值范围+1，详见补码表示法），但是值的绝对值范围减小了")]),v._v(" "),l("h3",[v._v("原码表示法")]),v._v(" "),l("p",[v._v("正数第一位为0，负数第一位为1。（如果是纯小数，则个位为符号位）")]),v._v(" "),l("p",[v._v("原码有两个0，以8位二进制数为例：")]),v._v(" "),l("ul",[l("li",[l("code",{pre:!0},[v._v("[+0] = 00000000")])]),v._v(" "),l("li",[l("code",{pre:!0},[v._v("[-0] = 10000000")])])]),v._v(" "),l("p",[v._v("原码表示法简单明了，易于和真值转换，但是"),l("strong",[v._v("加法运算复杂")]),v._v("（因为需要考虑第一位的正负而不能直接把8位数相加）")]),v._v(" "),l("h3",[v._v("反码表示法")]),v._v(" "),l("p",[l("strong",[v._v("正数的反码和原码一样")]),v._v("，负数的反码为原码二进制取反但是"),l("strong",[v._v("符号位仍然是1")]),v._v("，也就是说"),l("strong",[v._v("取反操作不对符号位生效")])]),v._v(" "),l("p",[v._v("0的反码：")]),v._v(" "),l("ul",[l("li",[l("code",{pre:!0},[v._v("[+0] = 00000000")])]),v._v(" "),l("li",[l("code",{pre:!0},[v._v("[-0] = 11111111")])])]),v._v(" "),l("h3",[v._v("补码表示法")]),v._v(" "),l("p",[l("strong",[v._v("正数的补码和原码一样，负数的补码相当于反码+1")])]),v._v(" "),l("p",[v._v("补码的原理：在数的长度一定时，可以使用补码来代替负数进行加减法。即计算0111+(-0011)和计算0111+1101的结果分别为0100和10100（舍弃首位1，结果相同）")]),v._v(" "),l("p",[v._v("0的补码：")]),v._v(" "),l("ul",[l("li",[l("code",{pre:!0},[v._v("[+0] = 00000000")])]),v._v(" "),l("li",[l("code",{pre:!0},[v._v("[-0] = 00000000")])])]),v._v(" "),l("p",[l("strong",[v._v("使用补码可以把减法运算变成加法运算")])]),v._v(" "),l("p",[v._v("如果使用原码，一个正数加一个负数不能直接把两个数的原码相加得到结果。如果使用补码，一个正数的补码加一个负数补码可以直接带上符号相加，得到的就是结果的补码")]),v._v(" "),l("p",[v._v("补码的补码等于自身")]),v._v(" "),l("h3",[v._v("移码表示法")]),v._v(" "),l("p",[v._v("通常用来表示浮点数的阶码")]),v._v(" "),l("p",[v._v("移码把真值向右移动变成了非负数，即把n-1位真值（一位符号位）加上2的n次方得到移码")]),v._v(" "),l("p",[v._v("以6位移码举例")]),v._v(" "),l("ul",[l("li",[l("code",{pre:!0},[v._v("[+10101] = 1000000 + 10101 = 1,10101")])]),v._v(" "),l("li",[l("code",{pre:!0},[v._v("[-10101] = 1000000 + (-10101) = 0,10101")])])]),v._v(" "),l("p",[v._v("可以看到，移码使用了一个**逗号（不是小数点）**把第一位分离了出来，显然第一位为1时是非负数，为0时是负数")]),v._v(" "),l("h3",[v._v("原码、反码、补码、移码小结")]),v._v(" "),l("p",[l("img",{attrs:{src:n(440),alt:"2-1"}})]),v._v(" "),l("ul",[l("li",[v._v("四种码制用来解决"),l("strong",[v._v("有符号数")]),v._v("在机器中的表示与运算。无符号数只有原码就够了")]),v._v(" "),l("li",[l("strong",[v._v("正数的原码、反码、补码是一样的")])]),v._v(" "),l("li",[v._v("只有移码的正号是1，负号是0，其他都是正号为0负号为1")]),v._v(" "),l("li",[v._v("原码与反码的0有两种编码。如果码长8位，负数只能表示到-127")]),v._v(" "),l("li",[v._v("补码和移码的0有唯一编码，所以负数可以表示到-128")])]),v._v(" "),l("p",[v._v("例题：令"),l("code",{pre:!0},[v._v("x = 103, y = -25")]),v._v("，下列表达式采用8位定点补码运算时会溢出的是？")]),v._v(" "),l("ul",[l("li",[v._v("A x+y")]),v._v(" "),l("li",[v._v("B -x+y")]),v._v(" "),l("li",[v._v("C x-y")]),v._v(" "),l("li",[v._v("D -x-y")])]),v._v(" "),l("p",[v._v("因为定点补码能够表示-128所以B不会溢出。而定点补码不能表示128所以C会溢出")]),v._v(" "),l("h3",[v._v("符号位扩展")]),v._v(" "),l("p",[v._v("将n位有符号数转换为n+k位并保持值不变。显然添加的位应该在原串左侧")]),v._v(" "),l("p",[v._v("规则：原串的第一位是0就全补0，是1就全补1")]),v._v(" "),l("h3",[v._v("移位操作")]),v._v(" "),l("ul",[l("li",[v._v("左移一位相当于乘2，右移一位相当于除2（向下取整）")]),v._v(" "),l("li",[v._v("使用移位与加减法来实现乘除法")]),v._v(" "),l("li",[v._v("移位法则\n"),l("ul",[l("li",[v._v("正数：原码、补码、反码均补0")]),v._v(" "),l("li",[v._v("负数\n"),l("ul",[l("li",[v._v("原码补0")]),v._v(" "),l("li",[v._v("反码补1")]),v._v(" "),l("li",[v._v("补码左移补0右移补1")])])])])]),v._v(" "),l("li",[v._v("超过串长的位丢弃")])]),v._v(" "),l("p",[v._v("例题：某机字长8位，已知整型变量x的补码为11110100，整型变量y的补码为10110000，求整型变量"),l("code",{pre:!0},[v._v("z=2*x+y/2")])]),v._v(" "),l("p",[v._v("首先进行移位，"),l("code",{pre:!0},[v._v("x*2")]),v._v("得到11101000，"),l("code",{pre:!0},[v._v("y/2")]),v._v("得到11011000，然后相加。补码的相加，直接相加即可。得到111000000，第一位越界舍弃，z为11000000")]),v._v(" "),l("h2",[v._v("浮点数的表示方法")]),v._v(" "),l("h3",[v._v("基本思想")]),v._v(" "),l("p",[v._v("使用"),l("strong",[v._v("科学计数法")])]),v._v(" "),l("p",[v._v("以"),l("code",{pre:!0},[v._v("2.13*10^19")]),v._v("为例，"),l("code",{pre:!0},[v._v("2.13")]),v._v("为"),l("strong",[v._v("尾数")]),v._v("，"),l("strong",[v._v("10")]),v._v("为"),l("strong",[v._v("基数")]),v._v("，"),l("strong",[v._v("19")]),v._v("为"),l("strong",[v._v("阶")])]),v._v(" "),l("ul",[l("li",[v._v("尾数常用原码或补码表示。尾数的有效数字位数决定了浮点数的精度")]),v._v(" "),l("li",[v._v("阶为定点整数，常用移码或补码表示。阶码决定了浮点数的表示范围")])]),v._v(" "),l("h3",[v._v("规格化尾数")]),v._v(" "),l("p",[l("strong",[v._v("规格化形式")]),v._v("："),l("strong",[v._v("尾数为纯小数且最高位必须为1")]),v._v("（原码表示时为1，如果是补码或反码的负数则最高位为0），个位表示符号，0为正1为负")]),v._v(" "),l("p",[v._v("每个小数都可以转换成一个唯一的规格化数")]),v._v(" "),l("p",[v._v("尾数的规格化表格：")]),v._v(" "),l("p",[l("img",{attrs:{src:n(441),alt:"2-2"}})]),v._v(" "),l("p",[v._v("特例：")]),v._v(" "),l("ul",[l("li",[l("code",{pre:!0},[v._v("x=-1/2=-0.100...0")]),v._v("的补码"),l("code",{pre:!0},[v._v("1.100...0")]),v._v("在补码中不是规格化数")]),v._v(" "),l("li",[l("code",{pre:!0},[v._v("x=-1")]),v._v("的补码"),l("code",{pre:!0},[v._v("1.00...00")]),v._v("是规格化数")])]),v._v(" "),l("h3",[v._v("IEEE754浮点数标准")]),v._v(" "),l("p",[l("img",{attrs:{src:n(442),alt:"2-11"}})]),v._v(" "),l("p",[v._v("在机器中从左向右分为三个部分")]),v._v(" "),l("ul",[l("li",[v._v("S\n"),l("ul",[l("li",[v._v("1位")]),v._v(" "),l("li",[v._v("浮点数的符号位，0表示正数，1表示负数")])])]),v._v(" "),l("li",[v._v("Exp\n"),l("ul",[l("li",[v._v("阶码，用"),l("strong",[v._v("移码")]),v._v("表示")]),v._v(" "),l("li",[v._v("float为8位，double为11位")]),v._v(" "),l("li",[v._v("Bias偏移量，float为127(2^7-1)，double为1023(2^10-1)")])])]),v._v(" "),l("li",[v._v("Frac\n"),l("ul",[l("li",[v._v("小数字段，用"),l("strong",[v._v("原码")]),v._v("表示")]),v._v(" "),l("li",[v._v("float为23位，double为20位")]),v._v(" "),l("li",[v._v("小数点在尾域的最前面。"),l("strong",[v._v("规格化数中")]),v._v("尾数"),l("code",{pre:!0},[v._v("M=1+Frac")]),v._v("（即隐含最高位的1，提升精度，非规格化数中没有这个规则）")])])])]),v._v(" "),l("p",[v._v("关于移码表示的阶码：")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("最小的阶为00…001")])]),v._v(" "),l("li",[l("strong",[v._v("最大的阶为11…110")])])]),v._v(" "),l("p",[l("strong",[v._v("阶码为全0与全1被用来表示其他数")])]),v._v(" "),l("p",[v._v("特殊浮点数值：")]),v._v(" "),l("p",[l("img",{attrs:{src:n(443),alt:"2-3"}})]),v._v(" "),l("p",[v._v("非规格化数的阶为"),l("code",{pre:!0},[v._v("1 - Bias = 1 - 127 = -126")]),v._v("（不是-127，保证了非规格化数到规格化数的平滑过渡）")]),v._v(" "),l("h2",[v._v("定点加减法")]),v._v(" "),l("h3",[v._v("补码加减法规则")]),v._v(" "),l("ul",[l("li",[v._v("补码加法：符号位作为数的一部分参与运算")]),v._v(" "),l("li",[v._v("补码减法：减一个数等于加这个数的补码")])]),v._v(" "),l("h2",[v._v("溢出与检测")]),v._v(" "),l("h3",[v._v("溢出概念")]),v._v(" "),l("ul",[l("li",[v._v("正溢 - 运算结果为正且超过机器表示范围")]),v._v(" "),l("li",[v._v("负溢 - 运算结果为负且超过机器表示范围")]),v._v(" "),l("li",[v._v("上溢 - 结果的绝对值超过机器所能表示的最大绝对值(overflow)")]),v._v(" "),l("li",[v._v("下溢 - 结果的绝对值超过机器所能表示的最小绝对值(underflow)")])]),v._v(" "),l("h3",[v._v("溢出检测")]),v._v(" "),l("ul",[l("li",[v._v("双符号位法，即"),l("strong",[v._v("变形补码")]),v._v("法或"),l("strong",[v._v("模4补码")]),v._v("法")])]),v._v(" "),l("p",[v._v("变形补码：前两位为符号位，即00表示正数，11表示负数，两个符号位都参与运算，超过两个符号位的进位丢弃")]),v._v(" "),l("p",[v._v("溢出检测规则：如果结果的双符号位出现了01或10则溢出。最高符号位永远表示结果的正确符号")]),v._v(" "),l("p",[v._v("溢出举例：")]),v._v(" "),l("pre",[l("code",{pre:!0},[v._v("x = +1100\ny = +1000\n\nx变形补码 = 001100\ny变形补码 = 001000\n\nx + y\n = 001100\n + 001000\n = 010100\n两个符号位不同，溢出\n")])]),v._v(" "),l("p",[v._v("可以看到溢出的直观表现为“两个正数相加得到了负数”，类似也有“两个负数相加得到正数”")]),v._v(" "),l("ul",[l("li",[v._v("单符号位法")])]),v._v(" "),l("p",[v._v("从双符号位法可以看出，溢出的条件为“最高有效位与符号位只有一个进位”，由此得到单符号位溢出判别法："),l("strong",[v._v("如果最高有效位和符号位只有一个进位则判别为溢出")])]),v._v(" "),l("p",[v._v("举例：")]),v._v(" "),l("pre",[l("code",{pre:!0},[v._v("x = +1100\ny = +1000\n\nx补码 = 01100\ny补码 = 01000\n\nx + y\n = 01100\n + 01000\n = 10100\n\n最高有效位向符号位进位1\n但是最高有效位自身没有进位1，溢出\n")])]),v._v(" "),l("h3",[v._v("加法器")]),v._v(" "),l("p",[v._v("一位全加器FA")]),v._v(" "),l("p",[l("img",{attrs:{src:n(444),alt:"2-4"}})]),v._v(" "),l("p",[v._v("Ai和Bi为两个输入，Ci为前一位运算传来的进位，C(i+1)为此次运算生成的进位，Si为运算结果")]),v._v(" "),l("p",[v._v("先行加法器：直接用逻辑运算取代加法运算来获得进位（并行进位）")]),v._v(" "),l("p",[v._v("并行进位举例：某加法器进位链小组信号为C4C3C2C1，低位来的进位信号为C0，写出串行进位和并行进位下C4C3C2C1的表达式")]),v._v(" "),l("pre",[l("code",{pre:!0},[v._v("串行进位下，令\nGi = AiBi\nPi = Ai xor Bi\n则Ci = Gi + PiC(i-1)，即\nC1 = A1B1 + (A1 xor B1)C0\nC2 = A2B2 + (A2 xor B2)C1\nC3 = A3B3 + (A3 xor B3)C2\nC4 = A4B4 + (A4 xor B4)C3\n\n并行进位下，不等待进位\n直接把C(i-1)的表达式代入Ci中，得到\nC1 = G1 + P1C0\nC2 = G2 + P2(G1 + P1C0)\nC3 = G3 + P3(G2 + P2(G1 + P1C0))\nC4 = G4 + P4(G3 + P3(G2 + P2(G1 + P1C0)))\n")])]),v._v(" "),l("h2",[v._v("定点乘除法")]),v._v(" "),l("h3",[v._v("无符号阵列乘法")]),v._v(" "),l("p",[v._v("即把符号先单独拿出来，把两个数作为正数相乘，再把符号位加上")]),v._v(" "),l("p",[v._v("符号的计算只需要把两个数的符号做异或即可。下面只讨论两个正数相乘")]),v._v(" "),l("p",[l("strong",[v._v("部分积")]),v._v("：1位乘法计算出来的积")]),v._v(" "),l("p",[v._v("部分积举例："),l("code",{pre:!0},[v._v("A = 11011, B = 10101")]),v._v("，计算"),l("code",{pre:!0},[v._v("A*B")])]),v._v(" "),l("p",[v._v("令"),l("code",{pre:!0},[v._v("aibj")]),v._v("表示"),l("code",{pre:!0},[v._v("A")]),v._v("中第"),l("code",{pre:!0},[v._v("i")]),v._v("位乘"),l("code",{pre:!0},[v._v("B")]),v._v("中第"),l("code",{pre:!0},[v._v("j")]),v._v("位得到的部分积，则得到如下部分积矩阵")]),v._v(" "),l("pre",[l("code",{pre:!0},[v._v("a4b0=1 a3b0=1 a2b0=0 a1b0=1 a0b0=1\na4b1=0 a3b1=0 a2b1=0 a1b1=0 a0b1=0\na4b2=1 a3b2=1 a2b2=0 a1b2=1 a0b2=0\na4b3=0 a3b3=0 a2b3=0 a1b3=0 a0b3=0\na4b4=1 a3b4=1 a2b4=0 a1b4=1 a0b4=1\n")])]),v._v(" "),l("p",[v._v("按照乘法的原则，应该对这些部分积做如下操作来得到结果")]),v._v(" "),l("pre",[l("code",{pre:!0},[v._v("       11011\n +    00000\n +   11011\n +  00000\n + 11011\n")])]),v._v(" "),l("p",[v._v("所以设计如下阵列乘法器")]),v._v(" "),l("p",[l("img",{attrs:{src:n(445),alt:"2-5"}})]),v._v(" "),l("h3",[v._v("有符号阵列乘法")]),v._v(" "),l("p",[v._v("使用原码的机器可以直接使用无符号数乘法器进行运算，把符号单独处理即可")]),v._v(" "),l("p",[v._v("使用补码的机器使用间接补码乘法运算（直接补码乘法不要求掌握）")]),v._v(" "),l("p",[l("strong",[v._v("间接补码乘法")]),v._v("：")]),v._v(" "),l("ul",[l("li",[v._v("正数：尾数使用无符号数乘法器即可")]),v._v(" "),l("li",[v._v("负数：由补码求出其绝对值后再使用无符号数乘法器运算")]),v._v(" "),l("li",[v._v("符号位仍单独计算")]),v._v(" "),l("li",[v._v("如果乘积是负数，把乘积的绝对值经过求补电路得到补码（因为机器使用的是补码，所以结果需要求补而不能直接使用原码）")])]),v._v(" "),l("p",[v._v("求补电路：人工计算补码时是先求反码再+1。求补电路的策略是"),l("strong",[v._v("从数的最右端开始从右向左找到第一个1，这个1保持不变，这个1以左的所有位求反")])]),v._v(" "),l("p",[v._v("间接补码阵列乘法器：")]),v._v(" "),l("p",[l("img",{attrs:{src:n(446),alt:"2-6"}})]),v._v(" "),l("h3",[v._v("定点除法")]),v._v(" "),l("p",[l("strong",[v._v("加减交替法（不恢复余数法）")])]),v._v(" "),l("p",[v._v("利用了2进制数的特性")]),v._v(" "),l("ul",[l("li",[v._v("已知被除数Ci和除数B")]),v._v(" "),l("li",[v._v("计算Ci-B得到结果C(i+1)")]),v._v(" "),l("li",[v._v("如果C(i+1)为负（即第一位为1）则此位结果为0，下一次操作改为加法。C(i+1)左移一位")]),v._v(" "),l("li",[v._v("如果C(i+1)为正（即第一位为0）则此位结果为1，下一次操作仍为减法。C(i+1)左移一位")])]),v._v(" "),l("h2",[v._v("定点运算器的组成")]),v._v(" "),l("h3",[v._v("运算器的基本结构")]),v._v(" "),l("ul",[l("li",[v._v("算术逻辑运算单元ALU")]),v._v(" "),l("li",[v._v("阵列乘除法器")]),v._v(" "),l("li",[v._v("寄存器组")]),v._v(" "),l("li",[v._v("多路开关")]),v._v(" "),l("li",[v._v("三态缓冲器")]),v._v(" "),l("li",[v._v("数据总线")])]),v._v(" "),l("h3",[v._v("ALU内部结构")]),v._v(" "),l("p",[v._v("使用"),l("strong",[v._v("函数发生器")]),v._v("和"),l("strong",[v._v("全加器")]),v._v("实现")]),v._v(" "),l("p",[l("img",{attrs:{src:n(447),alt:"2-7"}})]),v._v(" "),l("p",[v._v("函数发生器根据功能选择信号把输入数据进行处理，变成能够通过全加器计算逻辑或算数运算的数据")]),v._v(" "),l("h2",[v._v("BCD码加法")]),v._v(" "),l("p",[v._v("矫正：BCD码进行十进制运算时，如果结果大于9，必须使结果+6得到修正值")]),v._v(" "),l("h2",[v._v("总线结构")]),v._v(" "),l("ul",[l("li",[v._v("单总线结构")])]),v._v(" "),l("p",[l("img",{attrs:{src:n(448),alt:"2-8"}})]),v._v(" "),l("p",[v._v("所有部件在同一个总线上，简单，但是速度慢")]),v._v(" "),l("ul",[l("li",[v._v("双总线结构")])]),v._v(" "),l("p",[l("img",{attrs:{src:n(449),alt:"2-9"}})]),v._v(" "),l("p",[v._v("两个操作数可以同时放入特殊寄存器，控制电路稍复杂，速度快")]),v._v(" "),l("ul",[l("li",[v._v("三总线结构")])]),v._v(" "),l("p",[l("img",{attrs:{src:n(450),alt:"2-10"}})]),v._v(" "),l("p",[v._v("两条总线输入一条总线输出，算术逻辑运算可以在一步控制下完成。控制电路复杂，速度快")]),v._v(" "),l("h2",[v._v("浮点数加减法")]),v._v(" "),l("h3",[v._v("算法")]),v._v(" "),l("ol",[l("li",[v._v("检查操作数是否为0（因为浮点运算复杂，先判断0可以有效减少运算量）")]),v._v(" "),l("li",[l("strong",[v._v("对阶")]),v._v("，以阶码大的数为基准，使阶码小的数"),l("strong",[v._v("右移")]),v._v("（此时移位不舍弃多余的位，在对结果舍入的时候再舍弃）")]),v._v(" "),l("li",[v._v("对尾数进行加减法求结果")]),v._v(" "),l("li",[v._v("规格化，舍入（可能再次规格化），进行溢出检查（阶码是否溢出）")])]),v._v(" "),l("h3",[v._v("对阶规则")]),v._v(" "),l("p",[v._v("为什么对阶时以阶码大的数为基准，阶码小的数右移？因为结果是以阶码大的数的精度决定的，阶码小的数需要牺牲精度")]),v._v(" "),l("h3",[v._v("结果规格化")]),v._v(" "),l("p",[v._v("左规：向左规格化")]),v._v(" "),l("ul",[l("li",[v._v("尾数为原码时，结果应为x.1xxxx")]),v._v(" "),l("li",[v._v("尾数为补码时，尾数的最高位应与符号位相反，否则左移，右侧补0，阶码-1")]),v._v(" "),l("li",[v._v("对IEEE754浮点格式，注意省略尾数的第一个1")])]),v._v(" "),l("p",[v._v("右规：向右规格化")]),v._v(" "),l("ul",[l("li",[v._v("尾数求和的结果为01.xxx或10.xxx时应将运算结果右移以实现规格化")]),v._v(" "),l("li",[v._v("尾数每右移1位阶码+1")])]),v._v(" "),l("h3",[v._v("舍入处理")]),v._v(" "),l("p",[v._v("有四种舍入方式")]),v._v(" "),l("ul",[l("li",[v._v("就近舍入")]),v._v(" "),l("li",[v._v("朝0舍入")]),v._v(" "),l("li",[v._v("朝正无穷舍入")]),v._v(" "),l("li",[v._v("朝负无穷舍入")])]),v._v(" "),l("p",[v._v("做题时0舍1入即可")]),v._v(" "),l("h3",[v._v("溢出判断")]),v._v(" "),l("ul",[l("li",[v._v("阶码上溢，视为正负无穷")]),v._v(" "),l("li",[v._v("阶码下溢，视为0")]),v._v(" "),l("li",[v._v("尾数上溢，尾数右移，阶码+1")]),v._v(" "),l("li",[v._v("尾数下溢，舍入处理")])]),v._v(" "),l("h2",[v._v("浮点数乘除法")]),v._v(" "),l("h2",[v._v("算法")]),v._v(" "),l("ol",[l("li",[v._v("检查操作数是否为0")]),v._v(" "),l("li",[v._v("阶码加减")]),v._v(" "),l("li",[v._v("尾数乘除")]),v._v(" "),l("li",[v._v("规格化与舍入")]),v._v(" "),l("li",[v._v("溢出检测")])])])}]};v.exports={attributes:{layout:"collection",title:"运算方法与运算器",collection:"ComputerOrganizationPrinciple"},vue:{render:l.render,staticRenderFns:l.staticRenderFns,component:{data:function(){return{templateRender:null}},render:function(v){return this.templateRender?this.templateRender():v("div","Rendering")},created:function(){this.templateRender=l.render,this.$options.staticRenderFns=l.staticRenderFns}}}}},440:function(v,_,n){v.exports=n.p+"img/3e757c7.png"},441:function(v,_,n){v.exports=n.p+"img/dea6227.png"},442:function(v,_,n){v.exports=n.p+"img/0b216b8.png"},443:function(v,_,n){v.exports=n.p+"img/9df71b5.png"},444:function(v,_,n){v.exports=n.p+"img/83bc26b.png"},445:function(v,_,n){v.exports=n.p+"img/ccc6377.png"},446:function(v,_,n){v.exports=n.p+"img/6179223.png"},447:function(v,_,n){v.exports=n.p+"img/2f9ba07.png"},448:function(v,_,n){v.exports=n.p+"img/e8e4914.png"},449:function(v,_,n){v.exports=n.p+"img/52cf265.png"},450:function(v,_,n){v.exports=n.p+"img/a3e7120.png"}}]);