(window.webpackJsonp=window.webpackJsonp||[]).push([[55,691,692,693,694,695],{1129:function(e,t,_){const v={render:function(){this.$createElement;return this._self._c,this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("div",{staticClass:"frontmatter-markdown"},[v("h2",[e._v("地址空间")]),e._v(" "),v("p",[e._v("每个主存中的进程都有它的"),v("strong",[e._v("地址空间address space")])]),e._v(" "),v("p",[e._v("可以使用一对寄存器(base register and limit register)表明一段地址空间，以此保护程序")]),e._v(" "),v("p",[v("img",{attrs:{src:_(864),alt:"8-1"}})]),e._v(" "),v("h2",[e._v("地址绑定")]),e._v(" "),v("p",[e._v("程序装入内存时，操作系统会为其分配空间。因为"),v("strong",[e._v("程序的逻辑地址和物理地址有可能不一致")]),e._v("，CPU执行指令的时候使用的是物理地址，所以需要地址转换")]),e._v(" "),v("p",[e._v("指令和数据的地址绑定可以发生在三个阶段：")]),e._v(" "),v("ul",[v("li",[e._v("compile time编译或汇编阶段产生绝对地址")]),e._v(" "),v("li",[e._v("load time程序进入内存时产生绝对地址")]),e._v(" "),v("li",[e._v("execution time运行时产生地址")])]),e._v(" "),v("p",[e._v("分类：")]),e._v(" "),v("ul",[v("li",[e._v("static address relocation静态地址重定位，在指令执行前完成地址变换\n"),v("ul",[v("li",[e._v("compile time")]),e._v(" "),v("li",[e._v("load time")])])]),e._v(" "),v("li",[e._v("dynamic address relocation动态地址重定位，指令执行时进行地址变换\n"),v("ul",[v("li",[e._v("execution time")])])])]),e._v(" "),v("p",[e._v("MMU(Memory-management unit)负责运行时地址绑定(run-time address mapping)")]),e._v(" "),v("h2",[e._v("swapping")]),e._v(" "),v("p",[e._v("交换是系统控制的。在内存和外存之间交换数据实现内存的扩充")]),e._v(" "),v("h2",[e._v("contiguous allocation连续分配")]),e._v(" "),v("p",[e._v("运行前把整个进程完全放进内存，每个进程使用一块连续的地址空间(a single contiguous section of memory)")]),e._v(" "),v("h3",[e._v("fixed-sized partitions固定分区法")]),e._v(" "),v("p",[e._v("内存被分为几个固定大小的partitions，每个partition可以装载一个process。当有一个分区空闲时就从等待队列中取出一个进程放入内存。")]),e._v(" "),v("p",[v("img",{attrs:{src:_(865),alt:"8-2"}})]),e._v(" "),v("h3",[e._v("MVT可变分区法")]),e._v(" "),v("p",[e._v("操作系统维护一个partition table记录哪些partition被使用，哪些不被使用。这些分区会产生hole。当一个新的process需要放入主存的时候，寻找一个适当的hole来放入。process执行完毕后如果有相邻的hole，这些hole会合并")]),e._v(" "),v("p",[v("img",{attrs:{src:_(866),alt:"8-3"}})]),e._v(" "),v("p",[e._v("hole的分配算法：")]),e._v(" "),v("ul",[v("li",[e._v("first-fit\n"),v("ul",[v("li",[e._v("找到第一个可行的Hole就放入")])])]),e._v(" "),v("li",[e._v("best-fit\n"),v("ul",[v("li",[e._v("找到big enough且最小的Hole。必须扫描整个hole的list")])])]),e._v(" "),v("li",[e._v("worst-fit\n"),v("ul",[v("li",[e._v("顾名思义，没用")])])])]),e._v(" "),v("h3",[e._v("Fragmentation")]),e._v(" "),v("p",[e._v("连续分配会产生碎片（即不被使用的小内存块）")]),e._v(" "),v("ul",[v("li",[e._v("内部碎片（fixed-sized会产生\n"),v("ul",[v("li",[e._v("在连续分配出来的地址空间中存在的碎片")])])]),e._v(" "),v("li",[e._v("外部碎片（MVT会产生\n"),v("ul",[v("li",[e._v("在连续分配的块之间的碎片")]),e._v(" "),v("li",[e._v("可以通过compaction减少外部碎片")])])])]),e._v(" "),v("h2",[e._v("Paging页式存储管理")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("物理地址")]),e._v("被分为固定大小的frames（帧、框架）\n"),v("ul",[v("li",[e._v("帧的大小必须是2的指数，如512B或8192B等")]),e._v(" "),v("li",[e._v("OS使用frame table记录")])])]),e._v(" "),v("li",[v("strong",[e._v("逻辑地址")]),e._v("被分为固定大小的pages（页）\n"),v("ul",[v("li",[e._v("OS使用page tables记录")]),e._v(" "),v("li",[e._v("每个进程都有一个page table")]),e._v(" "),v("li",[e._v("PCB中存的有指向此进程page table的指针")]),e._v(" "),v("li",[e._v("保存了每个页的访问权限(1 bit)")])])])]),e._v(" "),v("p",[e._v("帧和页一一对应。程序不连续存储，而是使用很多不一定连续的页存储")]),e._v(" "),v("p",[e._v("OS使用page number和page offset来定位某个页中的某个地址")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("offset决定了每个页内数据的大小")]),e._v("，如offset有8位，则每个页中的数据就有2^8B")]),e._v(" "),v("li",[e._v("number决定了页表大小")])]),e._v(" "),v("h2",[e._v("页表的结构（略")]),e._v(" "),v("ul",[v("li",[e._v("多级页表")]),e._v(" "),v("li",[e._v("…")])]),e._v(" "),v("h2",[e._v("Segmentation段式存储管理")]),e._v(" "),v("p",[e._v("程序被分为很多段（比如每个函数一个段），每个段的长度可以不同。OS维护一个segmentation table")]),e._v(" "),v("p",[e._v("逻辑地址由段号+段内地址构成")]),e._v(" "),v("p",[v("img",{attrs:{src:_(867),alt:"8-4"}})]),e._v(" "),v("ul",[v("li",[e._v("比页式存储管理慢")]),e._v(" "),v("li",[e._v("会产生外部碎片（因为连续分配地址了")]),e._v(" "),v("li",[e._v("段越小，外部碎片越少")])]),e._v(" "),v("h2",[e._v("Segmentation with paging段页式存储管理")]),e._v(" "),v("p",[v("strong",[e._v("使用很多不连续的帧来构成段")]),e._v("，每个段内，物理地址需要使用page nummber & offset来指定")]),e._v(" "),v("p",[v("img",{attrs:{src:_(868),alt:"8-5"}})]),e._v(" "),v("p",[e._v("segment-table并不保存段的base address而是保存页的base address")])])}]};e.exports={attributes:{layout:"collection",title:"Memory Management",collection:"OperatingSystem"},vue:{render:v.render,staticRenderFns:v.staticRenderFns,component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=v.render,this.$options.staticRenderFns=v.staticRenderFns}}}}},864:function(e,t,_){e.exports=_.p+"img/785b624.png"},865:function(e,t,_){e.exports=_.p+"img/3df6b8a.png"},866:function(e,t,_){e.exports=_.p+"img/34eb664.png"},867:function(e,t,_){e.exports=_.p+"img/04ee77c.png"},868:function(e,t,_){e.exports=_.p+"img/06af7f7.png"}}]);